<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

<!-- 
  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  
-->





<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="js,es7,async/await," />





  <link rel="alternate" href="/atom.xml" title="coolcao的小站" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="在最开始学习ES6的Promise时，曾写过一篇博文《promise和co搭配生成器函数方式解决js代码异步流程的比较》，文章中对比了使用Promise和co模块搭配生成器函数解决js异步的异同。 在文章末尾，提到了ES7的async和await，只是当时只是简单的提了一下，并未做深入探讨。 在前两个月发布的Nodejs V7中，已添加了对async和await的支持，今天就来对这个东东做一下深入">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解ES7的async&#x2F;await">
<meta property="og:url" content="http://coolcao.com/2016/12/12/deeper-understanding-of-async-await/index.html">
<meta property="og:site_name" content="coolcao的小站">
<meta property="og:description" content="在最开始学习ES6的Promise时，曾写过一篇博文《promise和co搭配生成器函数方式解决js代码异步流程的比较》，文章中对比了使用Promise和co模块搭配生成器函数解决js异步的异同。 在文章末尾，提到了ES7的async和await，只是当时只是简单的提了一下，并未做深入探讨。 在前两个月发布的Nodejs V7中，已添加了对async和await的支持，今天就来对这个东东做一下深入">
<meta property="og:locale">
<meta property="article:published_time" content="2016-12-12T13:04:28.000Z">
<meta property="article:modified_time" content="2024-09-25T03:46:44.954Z">
<meta property="article:author" content="coolcao">
<meta property="article:tag" content="js">
<meta property="article:tag" content="es7">
<meta property="article:tag" content="async&#x2F;await">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://coolcao.com/2016/12/12/deeper-understanding-of-async-await/"/>


<link rel="stylesheet" type="text/css" href="/css/asciinema-player.css" />

  <title> 深入理解ES7的async/await | coolcao的小站 </title>
<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">coolcao的小站</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">coolcao的code点滴</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                深入理解ES7的async/await
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-12T21:04:28+08:00" content="2016-12-12">
              2016-12-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index">
                    <span itemprop="name">技术博客</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/%E5%8E%9F%E5%88%9B/" itemprop="url" rel="index">
                    <span itemprop="name">原创</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在最开始学习ES6的Promise时，曾写过一篇博文<a href="/2016/07/24/promise%E5%92%8Cco%E6%90%AD%E9%85%8D%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3js%E4%BB%A3%E7%A0%81%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83/">《promise和co搭配生成器函数方式解决js代码异步流程的比较》</a>，文章中对比了使用Promise和co模块搭配生成器函数解决js异步的异同。</p>
<p>在文章末尾，提到了ES7的async和await，只是当时只是简单的提了一下，并未做深入探讨。</p>
<p>在前两个月发布的Nodejs V7中，已添加了对async和await的支持，今天就来对这个东东做一下深入的探究。以更加优雅的方法写异步代码。</p>
<span id="more"></span>
<h2 id="async-x2F-await是什么"><a href="#async-x2F-await是什么" class="headerlink" title="async&#x2F;await是什么"></a>async&#x2F;await是什么</h2><p>async&#x2F;await可以说是co模块和生成器函数的语法糖。用更加清晰的语义解决js异步代码。</p>
<p>熟悉co模块的同学应该都知道，co模块是TJ大神写的一个使用生成器函数来解决异步流程的模块，可以看做是生成器函数的执行器。而async&#x2F;await则是对co模块的升级，内置生成器函数的执行器，不再依赖co模块。同时，async返回的是Promise。</p>
<p>从上面来看，不管是co模块还是async&#x2F;await，都是将Promise作为最基础的单元，对Promise不很了解的同学可以先深入了解一下Promise。</p>
<h2 id="对比Promise-co-async-x2F-await"><a href="#对比Promise-co-async-x2F-await" class="headerlink" title="对比Promise,co,async&#x2F;await"></a>对比Promise,co,async&#x2F;await</h2><p>下面我们使用一个简单的例子，来对比一下三种方式的异同，以及取舍。</p>
<p>我们采用mongodb的nodejs驱动，查询mongodb数据库作为例子，原因是mongodb的js驱动已经默认实现了返回Promise，而不用我们单独去包装Promise了。</p>
<h3 id="使用Promise链"><a href="#使用Promise链" class="headerlink" title="使用Promise链"></a>使用Promise链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url + db_name).<span class="title function_">then</span>(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.<span class="title function_">collection</span>(<span class="string">&#x27;blogs&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">coll</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> coll.<span class="title function_">find</span>().<span class="title function_">toArray</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">blogs</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(blogs.<span class="property">length</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise的then()方法可以返回另一个Promise，也可以返回一个同步的值，如果返回的是一个同步值，将会被包装成一个Promise。<br>上面的例子中，db.collection()将返回一个同步的值，即集合对象，但是被包装成Promise，将会透传到下一个then()方法。<br>上面一个例子，是使用的Promise链。<br>先连接数据库MongoClient.connect()返回一个Promise，然后在then()方法里获得数据库对象db，然后再获取到coll对象再返回。在下一个then()方法获得coll对象，然后进行查询，查询结果返回，逐层调用then()方法，形成一个Promise链。<br>在这个Promise链上，如果任何一个环节出现异常，都会被最后的catch()捕捉到。<br>可以说，这个使用Promise链写的代码，比层层调用回调函数更优雅，流程也更明确。先获得数据库对象，再获得集合对象，最后查询数据。<br>但是这里有个不怎么“优雅”的问题，在于，每一个then()方法获取的对象，都是上一个then()方法返回的数据。而不能跨层访问。<br>什么意思，就是说在第三个then(blogs &#x3D;&gt; {})中我们只能获取到查询的结果blogs，而不能使用上面的db对象和coll对象。这个时候，如果要打印出blogs列表后，要关闭数据库db.close()怎么办？<br>这个时候，可以两种解决方法：<br>第一种是，使用then()嵌套。我们将Promise链打断，使之嵌套，犹如使用回调函数的嵌套一般：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url + db_name).<span class="title function_">then</span>(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> coll = db.<span class="title function_">collection</span>(<span class="string">&#x27;blogs&#x27;</span>);</span><br><span class="line">    coll.<span class="title function_">find</span>().<span class="title function_">toArray</span>().<span class="title function_">then</span>(<span class="function"><span class="params">blogs</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(blogs.<span class="property">length</span>);</span><br><span class="line">        db.<span class="title function_">close</span>();</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里我们将两个Promise嵌套，这样在最后一个查询操作里面，就可以调用外面的db对象了。但是这种方式，并不推荐。原因很简单，我们从一种回调函数地狱走向了另一种Promise回调地狱。<br>而且，我们要对每个Promise的异常进行捕捉，因为Promise没有形成链。</p>
<p>还有一种方式， 是在每个then()方法里都将db传过来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url + db_name).<span class="title function_">then</span>(<span class="function"><span class="params">db</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">db</span>:db,<span class="attr">coll</span>:db.<span class="title function_">collection</span>(<span class="string">&#x27;blogs&#x27;</span>)&#125;;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">db</span>:result.<span class="property">db</span>,<span class="attr">blogs</span>:result.<span class="property">coll</span>.<span class="title function_">find</span>().<span class="title function_">toArray</span>()&#125;;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="property">blogs</span>.<span class="title function_">then</span>(<span class="function"><span class="params">blogs</span> =&gt;</span> &#123;   <span class="comment">//注意这里，result.coll.find().toArray()返回的是一个Promise，因此这里需要再解析一层</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">db</span>:result.<span class="property">db</span>,<span class="attr">blogs</span>:blogs&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">blogs</span>.<span class="property">length</span>);</span><br><span class="line">    result.<span class="property">db</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们在每个then()方法的返回中，都将db及其每次的其他结果组成一个对象返回。请注意，如果每次的结果都是一个同步的值还好说，但是如果是一个Promise值，每一个Promise都需要多做一层解析。<br>例如上面的一个例子，第二个then()方法返回的<code>&#123;db:result.db,blogs:result.coll.find().toArray()&#125;</code>对象中，<code>blogs</code>是一个Promise，在下一个then()方法中，我们无法直接引用博客列表数组值，因此需要先调用then()方法解析一层，然后将两个同步值db和blogs返回。<br>注意，这里涉及到了Promise的嵌套，不过一个Promise只嵌套一层then()。<br>这种方式，也是很蛋疼的一个方式，因为如果遇到then()方法中返回的不是同步的值，而是Promise的话，我们需要多做很多工作。而且，每次都透传一个“多余”的db对象，在逻辑上也有点冗余。</p>
<p>但除此之外，对于Promise链的使用，如果遇到上面的问题，好像也没其他更好的方法解决了。我们只能根据场景去选择一种“最优”的方案，如果要使用Promise链的话。</p>
<p>鉴于Promise上面蛋疼的问题，TJ大神将ES6中的生成器函数，用co模块包装了一下，以更优雅的方式来解决上面的问题。</p>
<h3 id="co搭配生成器函数"><a href="#co搭配生成器函数" class="headerlink" title="co搭配生成器函数"></a>co搭配生成器函数</h3><p>如果使用co模块搭配生成器函数，那么上面的例子可以改写如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* ()&#123;</span><br><span class="line">    <span class="keyword">let</span> db = <span class="keyword">yield</span> <span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url + db_name);</span><br><span class="line">    <span class="keyword">let</span> coll = db.<span class="title function_">collection</span>(<span class="string">&#x27;blogs&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> blogs = <span class="keyword">yield</span> coll.<span class="title function_">find</span>().<span class="title function_">toArray</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(blogs.<span class="property">length</span>);</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>co是一个函数，将接受一个生成器函数作为参数，去执行这个生成器函数。生成器函数中使用<code>yield</code>关键字来“同步”获取每个异步操作的值。<br>上面代码在代码形式上，比上面使用Promise链要优雅，我们消灭了回调函数，代码看起来都是同步的。除了使用co和yield有点怪之外。</p>
<p>使用co模块，我们要将所有的操作包装成一个生成器函数，然后使用co()去调用这个生成器函数。看上去也还可以接受，但是ES的进化是不满足于此的，于是async&#x2F;await被提到了ES7的提案。</p>
<h3 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><p>我们先看一下使用async&#x2F;await改写上面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> db = <span class="keyword">await</span> <span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url + db_name);</span><br><span class="line">    <span class="keyword">let</span> coll = db.<span class="title function_">collection</span>(<span class="string">&#x27;blogs&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> blogs = <span class="keyword">await</span> coll.<span class="title function_">find</span>().<span class="title function_">toArray</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(blogs.<span class="property">length</span>);</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">&#125;)().<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们对比代码可以看出，async&#x2F;await和co两种方式代码极为相似。<br>co换成了async，yield换成了await。同时生成器函数变成了普通函数。<br>这种方式在语义上更加清晰明了，async表明这个函数是异步的，同时await表示要“等待”异步操作返回值。<br>async函数返回一个Promise，上面的代码其实是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getBlogs = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> db = <span class="keyword">await</span> <span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url + db_name);</span><br><span class="line">    <span class="keyword">let</span> coll = db.<span class="title function_">collection</span>(<span class="string">&#x27;blogs&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> blogs = <span class="keyword">await</span> coll.<span class="title function_">find</span>().<span class="title function_">toArray</span>();</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">return</span> blogs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getBlogs</span>().<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">length</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们定义getBlogs为一个async函数，最后返回得到的博客列表最终会被包装成一个Promise返回，如上，我们直接调用getBlogs().then()方法可获取async函数返回值。</p>
<p>好了，上面我们简单对比了一下三种解决异步方案，下面我们来深入了解一下async&#x2F;await。</p>
<h2 id="深入async-x2F-await"><a href="#深入async-x2F-await" class="headerlink" title="深入async&#x2F;await"></a>深入async&#x2F;await</h2><h3 id="async返回值"><a href="#async返回值" class="headerlink" title="async返回值"></a>async返回值</h3><p>async用于定义一个异步函数，该函数返回一个Promise。<br>如果async函数返回的是一个同步的值，这个值将被包装成一个理解resolve的Promise，等同于<code>return Promise.resolve(value)</code>。<br>await用于一个异步操作之前，表示要“等待”这个异步操作的返回值。await也可以用于一个同步的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个Promise</span></span><br><span class="line"><span class="keyword">let</span> timer = <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;500&#x27;</span>);</span><br><span class="line">        &#125;,<span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timer</span>().<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);  <span class="comment">//500</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个同步的值</span></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> hi = <span class="keyword">await</span> <span class="string">&#x27;hello world&#x27;</span>;   </span><br><span class="line">  <span class="keyword">return</span> hi;  <span class="comment">//等同于return Promise.resolve(hi);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>().<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面这个例子返回是一个同步的值，字符串’hello world’，sayHi()是一个async函数，返回值被包装成一个Promise，可以调用then()方法获取返回值。<br>对于一个同步的值，可以使用await，也可以不使用await。效果效果是一样的。具体用不用，看情况。<br>比如上面使用mongodb查询博客那个例子，<code>let coll = db.collection(&#39;blogs&#39;);</code>，这里我们就没有用await，因为这是一个同步的值。当然，也可以使用await，这样会显得代码统一。虽然效果是一样的。</p>
<h3 id="async函数的异常"><a href="#async函数的异常" class="headerlink" title="async函数的异常"></a>async函数的异常</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHi</span>().<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);   <span class="comment">//出错了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们直接在async函数中抛出一个异常，由于返回的是一个Promise，因此，这个异常可以调用返回Promise的catch()方法捕捉到。</p>
<p>和Promise链的对比：<br>我们的async函数中可以包含多个异步操作，其异常和Promise链有相同之处，如果有一个Promise被reject()那么后面的将不会再进行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">count</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;故意抛出错误&#x27;</span>);</span><br><span class="line">        &#125;,<span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">list</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">        &#125;,<span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">getList</span> = <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">await</span> <span class="title function_">count</span>();</span><br><span class="line">    <span class="keyword">let</span> l = <span class="keyword">await</span> <span class="title function_">list</span>();</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>:c,<span class="attr">list</span>:l&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;begin&#x27;</span>);</span><br><span class="line"><span class="title function_">getList</span>().<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;begin&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//begin: 507.490ms</span></span><br><span class="line"><span class="comment">//故意抛出错误</span></span><br></pre></td></tr></table></figure>
<p>如上面的代码，定义两个异步操作，count和list，使用setTimeout延时500毫秒，count故意直接抛出异常，从输出结果来看，count()抛出异常后，直接由catch()捕捉到了，list()并没有继续执行。</p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>使用async后，我们上面的例子都是串行的。比如上个list()和count()的例子，我们可以将这个例子用作分页查询数据的场景。<br>先查询出数据库中总共有多少条记录，然后再根据分页条件查询分页数据，最后返回分页数据以及分页信息。<br>我们上面的例子count()和list()有个“先后顺序”，即我们先查的总数，然后又查的列表。其实，这两个操作并无先后关联性，我们可以异步的同时进行查询，然后等到所有结果都返回时再拼装数据即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">count</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">100</span>);</span><br><span class="line">        &#125;,<span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">list</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">        &#125;,<span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">getList</span> = <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">count</span>(),<span class="title function_">list</span>()]);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;begin&#x27;</span>);</span><br><span class="line"><span class="title function_">getList</span>().<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;begin&#x27;</span>);  <span class="comment">//begin: 505.557ms</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);       <span class="comment">//[ 100, [ 1, 2, 3 ] ]</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;begin&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们将count()和list()使用Promise.all()“同时”执行，这里count()和list()可以看作是“并行”执行的，所耗时间将是两个异步操作中耗时最长的耗时。<br>最后得到的结果是两个操作的结果组成的数组。我们只需要按照顺序取出数组中的值即可。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/js/" rel="tag">#js</a>
          
            <a href="/tags/es7/" rel="tag">#es7</a>
          
            <a href="/tags/async-await/" rel="tag">#async/await</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/12/experimenting-with-async-await-in-nodejs-v7/" rel="next" title="【译】nodejs v7初体验之async/await">
                <i class="fa fa-chevron-left"></i> 【译】nodejs v7初体验之async/await
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/13/difference-of-node-mongodb-native-and-shell-in-capped-collection/" rel="prev" title="node-mongodb-native原生驱动在固定集合上的坑">
                node-mongodb-native原生驱动在固定集合上的坑 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/logo.svg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">91</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">114</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/coolcao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/1946282212" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#async-x2F-await是什么"><span class="nav-number">1.</span> <span class="nav-text">async&#x2F;await是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对比Promise-co-async-x2F-await"><span class="nav-number">2.</span> <span class="nav-text">对比Promise,co,async&#x2F;await</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Promise链"><span class="nav-number">2.1.</span> <span class="nav-text">使用Promise链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#co搭配生成器函数"><span class="nav-number">2.2.</span> <span class="nav-text">co搭配生成器函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async-x2F-await"><span class="nav-number">2.3.</span> <span class="nav-text">async&#x2F;await</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入async-x2F-await"><span class="nav-number">3.</span> <span class="nav-text">深入async&#x2F;await</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#async返回值"><span class="nav-number">3.1.</span> <span class="nav-text">async返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async函数的异常"><span class="nav-number">3.2.</span> <span class="nav-text">async函数的异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并行"><span class="nav-number">3.3.</span> <span class="nav-text">并行</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">coolcao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


  

  <script src="/js/coze.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/asciinema-player@2.6.1/resources/public/js/asciinema-player.min.js"></script>

  <script>
      new CozeWebSDK.WebChatClient({
        config: {
          bot_id: '7369590614474145808',
        },
        componentProps: {
          icon: 'https://coolcao.com/images/chat.svg',
          title: 'coolcao的小站',
        },
      });
  </script>


</body>
</html>
